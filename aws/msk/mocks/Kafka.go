// Code generated by mockery v2.20.0. DO NOT EDIT.

package mocks

import (
	context "context"

	kafka "github.com/aws/aws-sdk-go/service/kafka"
	mock "github.com/stretchr/testify/mock"

	request "github.com/aws/aws-sdk-go/aws/request"
)

// Kafka is an autogenerated mock type for the Kafka type
type Kafka struct {
	mock.Mock
}

// BatchAssociateScramSecret provides a mock function with given fields: _a0
func (_m *Kafka) BatchAssociateScramSecret(_a0 *kafka.BatchAssociateScramSecretInput) (*kafka.BatchAssociateScramSecretOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.BatchAssociateScramSecretOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.BatchAssociateScramSecretInput) (*kafka.BatchAssociateScramSecretOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.BatchAssociateScramSecretInput) *kafka.BatchAssociateScramSecretOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.BatchAssociateScramSecretOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.BatchAssociateScramSecretInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchAssociateScramSecretRequest provides a mock function with given fields: _a0
func (_m *Kafka) BatchAssociateScramSecretRequest(_a0 *kafka.BatchAssociateScramSecretInput) (*request.Request, *kafka.BatchAssociateScramSecretOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.BatchAssociateScramSecretOutput
	if rf, ok := ret.Get(0).(func(*kafka.BatchAssociateScramSecretInput) (*request.Request, *kafka.BatchAssociateScramSecretOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.BatchAssociateScramSecretInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.BatchAssociateScramSecretInput) *kafka.BatchAssociateScramSecretOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.BatchAssociateScramSecretOutput)
		}
	}

	return r0, r1
}

// BatchAssociateScramSecretWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) BatchAssociateScramSecretWithContext(_a0 context.Context, _a1 *kafka.BatchAssociateScramSecretInput, _a2 ...request.Option) (*kafka.BatchAssociateScramSecretOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.BatchAssociateScramSecretOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.BatchAssociateScramSecretInput, ...request.Option) (*kafka.BatchAssociateScramSecretOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.BatchAssociateScramSecretInput, ...request.Option) *kafka.BatchAssociateScramSecretOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.BatchAssociateScramSecretOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.BatchAssociateScramSecretInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDisassociateScramSecret provides a mock function with given fields: _a0
func (_m *Kafka) BatchDisassociateScramSecret(_a0 *kafka.BatchDisassociateScramSecretInput) (*kafka.BatchDisassociateScramSecretOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.BatchDisassociateScramSecretOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.BatchDisassociateScramSecretInput) (*kafka.BatchDisassociateScramSecretOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.BatchDisassociateScramSecretInput) *kafka.BatchDisassociateScramSecretOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.BatchDisassociateScramSecretOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.BatchDisassociateScramSecretInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDisassociateScramSecretRequest provides a mock function with given fields: _a0
func (_m *Kafka) BatchDisassociateScramSecretRequest(_a0 *kafka.BatchDisassociateScramSecretInput) (*request.Request, *kafka.BatchDisassociateScramSecretOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.BatchDisassociateScramSecretOutput
	if rf, ok := ret.Get(0).(func(*kafka.BatchDisassociateScramSecretInput) (*request.Request, *kafka.BatchDisassociateScramSecretOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.BatchDisassociateScramSecretInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.BatchDisassociateScramSecretInput) *kafka.BatchDisassociateScramSecretOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.BatchDisassociateScramSecretOutput)
		}
	}

	return r0, r1
}

// BatchDisassociateScramSecretWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) BatchDisassociateScramSecretWithContext(_a0 context.Context, _a1 *kafka.BatchDisassociateScramSecretInput, _a2 ...request.Option) (*kafka.BatchDisassociateScramSecretOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.BatchDisassociateScramSecretOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.BatchDisassociateScramSecretInput, ...request.Option) (*kafka.BatchDisassociateScramSecretOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.BatchDisassociateScramSecretInput, ...request.Option) *kafka.BatchDisassociateScramSecretOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.BatchDisassociateScramSecretOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.BatchDisassociateScramSecretInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCluster provides a mock function with given fields: _a0
func (_m *Kafka) CreateCluster(_a0 *kafka.CreateClusterInput) (*kafka.CreateClusterOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.CreateClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.CreateClusterInput) (*kafka.CreateClusterOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.CreateClusterInput) *kafka.CreateClusterOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.CreateClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.CreateClusterInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClusterRequest provides a mock function with given fields: _a0
func (_m *Kafka) CreateClusterRequest(_a0 *kafka.CreateClusterInput) (*request.Request, *kafka.CreateClusterOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.CreateClusterOutput
	if rf, ok := ret.Get(0).(func(*kafka.CreateClusterInput) (*request.Request, *kafka.CreateClusterOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.CreateClusterInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.CreateClusterInput) *kafka.CreateClusterOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.CreateClusterOutput)
		}
	}

	return r0, r1
}

// CreateClusterV2 provides a mock function with given fields: _a0
func (_m *Kafka) CreateClusterV2(_a0 *kafka.CreateClusterV2Input) (*kafka.CreateClusterV2Output, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.CreateClusterV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.CreateClusterV2Input) (*kafka.CreateClusterV2Output, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.CreateClusterV2Input) *kafka.CreateClusterV2Output); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.CreateClusterV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.CreateClusterV2Input) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClusterV2Request provides a mock function with given fields: _a0
func (_m *Kafka) CreateClusterV2Request(_a0 *kafka.CreateClusterV2Input) (*request.Request, *kafka.CreateClusterV2Output) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.CreateClusterV2Output
	if rf, ok := ret.Get(0).(func(*kafka.CreateClusterV2Input) (*request.Request, *kafka.CreateClusterV2Output)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.CreateClusterV2Input) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.CreateClusterV2Input) *kafka.CreateClusterV2Output); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.CreateClusterV2Output)
		}
	}

	return r0, r1
}

// CreateClusterV2WithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) CreateClusterV2WithContext(_a0 context.Context, _a1 *kafka.CreateClusterV2Input, _a2 ...request.Option) (*kafka.CreateClusterV2Output, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.CreateClusterV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateClusterV2Input, ...request.Option) (*kafka.CreateClusterV2Output, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateClusterV2Input, ...request.Option) *kafka.CreateClusterV2Output); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.CreateClusterV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.CreateClusterV2Input, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClusterWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) CreateClusterWithContext(_a0 context.Context, _a1 *kafka.CreateClusterInput, _a2 ...request.Option) (*kafka.CreateClusterOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.CreateClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateClusterInput, ...request.Option) (*kafka.CreateClusterOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateClusterInput, ...request.Option) *kafka.CreateClusterOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.CreateClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.CreateClusterInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateConfiguration provides a mock function with given fields: _a0
func (_m *Kafka) CreateConfiguration(_a0 *kafka.CreateConfigurationInput) (*kafka.CreateConfigurationOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.CreateConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.CreateConfigurationInput) (*kafka.CreateConfigurationOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.CreateConfigurationInput) *kafka.CreateConfigurationOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.CreateConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.CreateConfigurationInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateConfigurationRequest provides a mock function with given fields: _a0
func (_m *Kafka) CreateConfigurationRequest(_a0 *kafka.CreateConfigurationInput) (*request.Request, *kafka.CreateConfigurationOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.CreateConfigurationOutput
	if rf, ok := ret.Get(0).(func(*kafka.CreateConfigurationInput) (*request.Request, *kafka.CreateConfigurationOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.CreateConfigurationInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.CreateConfigurationInput) *kafka.CreateConfigurationOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.CreateConfigurationOutput)
		}
	}

	return r0, r1
}

// CreateConfigurationWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) CreateConfigurationWithContext(_a0 context.Context, _a1 *kafka.CreateConfigurationInput, _a2 ...request.Option) (*kafka.CreateConfigurationOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.CreateConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateConfigurationInput, ...request.Option) (*kafka.CreateConfigurationOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateConfigurationInput, ...request.Option) *kafka.CreateConfigurationOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.CreateConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.CreateConfigurationInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcConnection provides a mock function with given fields: _a0
func (_m *Kafka) CreateVpcConnection(_a0 *kafka.CreateVpcConnectionInput) (*kafka.CreateVpcConnectionOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.CreateVpcConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.CreateVpcConnectionInput) (*kafka.CreateVpcConnectionOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.CreateVpcConnectionInput) *kafka.CreateVpcConnectionOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.CreateVpcConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.CreateVpcConnectionInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcConnectionRequest provides a mock function with given fields: _a0
func (_m *Kafka) CreateVpcConnectionRequest(_a0 *kafka.CreateVpcConnectionInput) (*request.Request, *kafka.CreateVpcConnectionOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.CreateVpcConnectionOutput
	if rf, ok := ret.Get(0).(func(*kafka.CreateVpcConnectionInput) (*request.Request, *kafka.CreateVpcConnectionOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.CreateVpcConnectionInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.CreateVpcConnectionInput) *kafka.CreateVpcConnectionOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.CreateVpcConnectionOutput)
		}
	}

	return r0, r1
}

// CreateVpcConnectionWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) CreateVpcConnectionWithContext(_a0 context.Context, _a1 *kafka.CreateVpcConnectionInput, _a2 ...request.Option) (*kafka.CreateVpcConnectionOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.CreateVpcConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateVpcConnectionInput, ...request.Option) (*kafka.CreateVpcConnectionOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.CreateVpcConnectionInput, ...request.Option) *kafka.CreateVpcConnectionOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.CreateVpcConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.CreateVpcConnectionInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCluster provides a mock function with given fields: _a0
func (_m *Kafka) DeleteCluster(_a0 *kafka.DeleteClusterInput) (*kafka.DeleteClusterOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.DeleteClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.DeleteClusterInput) (*kafka.DeleteClusterOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DeleteClusterInput) *kafka.DeleteClusterOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DeleteClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DeleteClusterInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClusterPolicy provides a mock function with given fields: _a0
func (_m *Kafka) DeleteClusterPolicy(_a0 *kafka.DeleteClusterPolicyInput) (*kafka.DeleteClusterPolicyOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.DeleteClusterPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.DeleteClusterPolicyInput) (*kafka.DeleteClusterPolicyOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DeleteClusterPolicyInput) *kafka.DeleteClusterPolicyOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DeleteClusterPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DeleteClusterPolicyInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClusterPolicyRequest provides a mock function with given fields: _a0
func (_m *Kafka) DeleteClusterPolicyRequest(_a0 *kafka.DeleteClusterPolicyInput) (*request.Request, *kafka.DeleteClusterPolicyOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.DeleteClusterPolicyOutput
	if rf, ok := ret.Get(0).(func(*kafka.DeleteClusterPolicyInput) (*request.Request, *kafka.DeleteClusterPolicyOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DeleteClusterPolicyInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DeleteClusterPolicyInput) *kafka.DeleteClusterPolicyOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.DeleteClusterPolicyOutput)
		}
	}

	return r0, r1
}

// DeleteClusterPolicyWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) DeleteClusterPolicyWithContext(_a0 context.Context, _a1 *kafka.DeleteClusterPolicyInput, _a2 ...request.Option) (*kafka.DeleteClusterPolicyOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.DeleteClusterPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteClusterPolicyInput, ...request.Option) (*kafka.DeleteClusterPolicyOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteClusterPolicyInput, ...request.Option) *kafka.DeleteClusterPolicyOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DeleteClusterPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DeleteClusterPolicyInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClusterRequest provides a mock function with given fields: _a0
func (_m *Kafka) DeleteClusterRequest(_a0 *kafka.DeleteClusterInput) (*request.Request, *kafka.DeleteClusterOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.DeleteClusterOutput
	if rf, ok := ret.Get(0).(func(*kafka.DeleteClusterInput) (*request.Request, *kafka.DeleteClusterOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DeleteClusterInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DeleteClusterInput) *kafka.DeleteClusterOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.DeleteClusterOutput)
		}
	}

	return r0, r1
}

// DeleteClusterWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) DeleteClusterWithContext(_a0 context.Context, _a1 *kafka.DeleteClusterInput, _a2 ...request.Option) (*kafka.DeleteClusterOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.DeleteClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteClusterInput, ...request.Option) (*kafka.DeleteClusterOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteClusterInput, ...request.Option) *kafka.DeleteClusterOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DeleteClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DeleteClusterInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteConfiguration provides a mock function with given fields: _a0
func (_m *Kafka) DeleteConfiguration(_a0 *kafka.DeleteConfigurationInput) (*kafka.DeleteConfigurationOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.DeleteConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.DeleteConfigurationInput) (*kafka.DeleteConfigurationOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DeleteConfigurationInput) *kafka.DeleteConfigurationOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DeleteConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DeleteConfigurationInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteConfigurationRequest provides a mock function with given fields: _a0
func (_m *Kafka) DeleteConfigurationRequest(_a0 *kafka.DeleteConfigurationInput) (*request.Request, *kafka.DeleteConfigurationOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.DeleteConfigurationOutput
	if rf, ok := ret.Get(0).(func(*kafka.DeleteConfigurationInput) (*request.Request, *kafka.DeleteConfigurationOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DeleteConfigurationInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DeleteConfigurationInput) *kafka.DeleteConfigurationOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.DeleteConfigurationOutput)
		}
	}

	return r0, r1
}

// DeleteConfigurationWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) DeleteConfigurationWithContext(_a0 context.Context, _a1 *kafka.DeleteConfigurationInput, _a2 ...request.Option) (*kafka.DeleteConfigurationOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.DeleteConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteConfigurationInput, ...request.Option) (*kafka.DeleteConfigurationOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteConfigurationInput, ...request.Option) *kafka.DeleteConfigurationOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DeleteConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DeleteConfigurationInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcConnection provides a mock function with given fields: _a0
func (_m *Kafka) DeleteVpcConnection(_a0 *kafka.DeleteVpcConnectionInput) (*kafka.DeleteVpcConnectionOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.DeleteVpcConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.DeleteVpcConnectionInput) (*kafka.DeleteVpcConnectionOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DeleteVpcConnectionInput) *kafka.DeleteVpcConnectionOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DeleteVpcConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DeleteVpcConnectionInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcConnectionRequest provides a mock function with given fields: _a0
func (_m *Kafka) DeleteVpcConnectionRequest(_a0 *kafka.DeleteVpcConnectionInput) (*request.Request, *kafka.DeleteVpcConnectionOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.DeleteVpcConnectionOutput
	if rf, ok := ret.Get(0).(func(*kafka.DeleteVpcConnectionInput) (*request.Request, *kafka.DeleteVpcConnectionOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DeleteVpcConnectionInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DeleteVpcConnectionInput) *kafka.DeleteVpcConnectionOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.DeleteVpcConnectionOutput)
		}
	}

	return r0, r1
}

// DeleteVpcConnectionWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) DeleteVpcConnectionWithContext(_a0 context.Context, _a1 *kafka.DeleteVpcConnectionInput, _a2 ...request.Option) (*kafka.DeleteVpcConnectionOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.DeleteVpcConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteVpcConnectionInput, ...request.Option) (*kafka.DeleteVpcConnectionOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DeleteVpcConnectionInput, ...request.Option) *kafka.DeleteVpcConnectionOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DeleteVpcConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DeleteVpcConnectionInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCluster provides a mock function with given fields: _a0
func (_m *Kafka) DescribeCluster(_a0 *kafka.DescribeClusterInput) (*kafka.DescribeClusterOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.DescribeClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterInput) (*kafka.DescribeClusterOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterInput) *kafka.DescribeClusterOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DescribeClusterInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterOperation provides a mock function with given fields: _a0
func (_m *Kafka) DescribeClusterOperation(_a0 *kafka.DescribeClusterOperationInput) (*kafka.DescribeClusterOperationOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.DescribeClusterOperationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterOperationInput) (*kafka.DescribeClusterOperationOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterOperationInput) *kafka.DescribeClusterOperationOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeClusterOperationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DescribeClusterOperationInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterOperationRequest provides a mock function with given fields: _a0
func (_m *Kafka) DescribeClusterOperationRequest(_a0 *kafka.DescribeClusterOperationInput) (*request.Request, *kafka.DescribeClusterOperationOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.DescribeClusterOperationOutput
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterOperationInput) (*request.Request, *kafka.DescribeClusterOperationOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterOperationInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DescribeClusterOperationInput) *kafka.DescribeClusterOperationOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.DescribeClusterOperationOutput)
		}
	}

	return r0, r1
}

// DescribeClusterOperationV2 provides a mock function with given fields: _a0
func (_m *Kafka) DescribeClusterOperationV2(_a0 *kafka.DescribeClusterOperationV2Input) (*kafka.DescribeClusterOperationV2Output, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.DescribeClusterOperationV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterOperationV2Input) (*kafka.DescribeClusterOperationV2Output, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterOperationV2Input) *kafka.DescribeClusterOperationV2Output); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeClusterOperationV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DescribeClusterOperationV2Input) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterOperationV2Request provides a mock function with given fields: _a0
func (_m *Kafka) DescribeClusterOperationV2Request(_a0 *kafka.DescribeClusterOperationV2Input) (*request.Request, *kafka.DescribeClusterOperationV2Output) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.DescribeClusterOperationV2Output
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterOperationV2Input) (*request.Request, *kafka.DescribeClusterOperationV2Output)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterOperationV2Input) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DescribeClusterOperationV2Input) *kafka.DescribeClusterOperationV2Output); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.DescribeClusterOperationV2Output)
		}
	}

	return r0, r1
}

// DescribeClusterOperationV2WithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) DescribeClusterOperationV2WithContext(_a0 context.Context, _a1 *kafka.DescribeClusterOperationV2Input, _a2 ...request.Option) (*kafka.DescribeClusterOperationV2Output, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.DescribeClusterOperationV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterOperationV2Input, ...request.Option) (*kafka.DescribeClusterOperationV2Output, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterOperationV2Input, ...request.Option) *kafka.DescribeClusterOperationV2Output); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeClusterOperationV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeClusterOperationV2Input, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterOperationWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) DescribeClusterOperationWithContext(_a0 context.Context, _a1 *kafka.DescribeClusterOperationInput, _a2 ...request.Option) (*kafka.DescribeClusterOperationOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.DescribeClusterOperationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterOperationInput, ...request.Option) (*kafka.DescribeClusterOperationOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterOperationInput, ...request.Option) *kafka.DescribeClusterOperationOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeClusterOperationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeClusterOperationInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterRequest provides a mock function with given fields: _a0
func (_m *Kafka) DescribeClusterRequest(_a0 *kafka.DescribeClusterInput) (*request.Request, *kafka.DescribeClusterOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.DescribeClusterOutput
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterInput) (*request.Request, *kafka.DescribeClusterOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DescribeClusterInput) *kafka.DescribeClusterOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.DescribeClusterOutput)
		}
	}

	return r0, r1
}

// DescribeClusterV2 provides a mock function with given fields: _a0
func (_m *Kafka) DescribeClusterV2(_a0 *kafka.DescribeClusterV2Input) (*kafka.DescribeClusterV2Output, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.DescribeClusterV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterV2Input) (*kafka.DescribeClusterV2Output, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterV2Input) *kafka.DescribeClusterV2Output); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeClusterV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DescribeClusterV2Input) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterV2Request provides a mock function with given fields: _a0
func (_m *Kafka) DescribeClusterV2Request(_a0 *kafka.DescribeClusterV2Input) (*request.Request, *kafka.DescribeClusterV2Output) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.DescribeClusterV2Output
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterV2Input) (*request.Request, *kafka.DescribeClusterV2Output)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DescribeClusterV2Input) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DescribeClusterV2Input) *kafka.DescribeClusterV2Output); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.DescribeClusterV2Output)
		}
	}

	return r0, r1
}

// DescribeClusterV2WithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) DescribeClusterV2WithContext(_a0 context.Context, _a1 *kafka.DescribeClusterV2Input, _a2 ...request.Option) (*kafka.DescribeClusterV2Output, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.DescribeClusterV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterV2Input, ...request.Option) (*kafka.DescribeClusterV2Output, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterV2Input, ...request.Option) *kafka.DescribeClusterV2Output); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeClusterV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeClusterV2Input, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClusterWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) DescribeClusterWithContext(_a0 context.Context, _a1 *kafka.DescribeClusterInput, _a2 ...request.Option) (*kafka.DescribeClusterOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.DescribeClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterInput, ...request.Option) (*kafka.DescribeClusterOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeClusterInput, ...request.Option) *kafka.DescribeClusterOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeClusterInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeConfiguration provides a mock function with given fields: _a0
func (_m *Kafka) DescribeConfiguration(_a0 *kafka.DescribeConfigurationInput) (*kafka.DescribeConfigurationOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.DescribeConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.DescribeConfigurationInput) (*kafka.DescribeConfigurationOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DescribeConfigurationInput) *kafka.DescribeConfigurationOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DescribeConfigurationInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeConfigurationRequest provides a mock function with given fields: _a0
func (_m *Kafka) DescribeConfigurationRequest(_a0 *kafka.DescribeConfigurationInput) (*request.Request, *kafka.DescribeConfigurationOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.DescribeConfigurationOutput
	if rf, ok := ret.Get(0).(func(*kafka.DescribeConfigurationInput) (*request.Request, *kafka.DescribeConfigurationOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DescribeConfigurationInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DescribeConfigurationInput) *kafka.DescribeConfigurationOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.DescribeConfigurationOutput)
		}
	}

	return r0, r1
}

// DescribeConfigurationRevision provides a mock function with given fields: _a0
func (_m *Kafka) DescribeConfigurationRevision(_a0 *kafka.DescribeConfigurationRevisionInput) (*kafka.DescribeConfigurationRevisionOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.DescribeConfigurationRevisionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.DescribeConfigurationRevisionInput) (*kafka.DescribeConfigurationRevisionOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DescribeConfigurationRevisionInput) *kafka.DescribeConfigurationRevisionOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeConfigurationRevisionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DescribeConfigurationRevisionInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeConfigurationRevisionRequest provides a mock function with given fields: _a0
func (_m *Kafka) DescribeConfigurationRevisionRequest(_a0 *kafka.DescribeConfigurationRevisionInput) (*request.Request, *kafka.DescribeConfigurationRevisionOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.DescribeConfigurationRevisionOutput
	if rf, ok := ret.Get(0).(func(*kafka.DescribeConfigurationRevisionInput) (*request.Request, *kafka.DescribeConfigurationRevisionOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DescribeConfigurationRevisionInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DescribeConfigurationRevisionInput) *kafka.DescribeConfigurationRevisionOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.DescribeConfigurationRevisionOutput)
		}
	}

	return r0, r1
}

// DescribeConfigurationRevisionWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) DescribeConfigurationRevisionWithContext(_a0 context.Context, _a1 *kafka.DescribeConfigurationRevisionInput, _a2 ...request.Option) (*kafka.DescribeConfigurationRevisionOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.DescribeConfigurationRevisionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeConfigurationRevisionInput, ...request.Option) (*kafka.DescribeConfigurationRevisionOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeConfigurationRevisionInput, ...request.Option) *kafka.DescribeConfigurationRevisionOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeConfigurationRevisionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeConfigurationRevisionInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeConfigurationWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) DescribeConfigurationWithContext(_a0 context.Context, _a1 *kafka.DescribeConfigurationInput, _a2 ...request.Option) (*kafka.DescribeConfigurationOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.DescribeConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeConfigurationInput, ...request.Option) (*kafka.DescribeConfigurationOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeConfigurationInput, ...request.Option) *kafka.DescribeConfigurationOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeConfigurationInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcConnection provides a mock function with given fields: _a0
func (_m *Kafka) DescribeVpcConnection(_a0 *kafka.DescribeVpcConnectionInput) (*kafka.DescribeVpcConnectionOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.DescribeVpcConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.DescribeVpcConnectionInput) (*kafka.DescribeVpcConnectionOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DescribeVpcConnectionInput) *kafka.DescribeVpcConnectionOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeVpcConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DescribeVpcConnectionInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcConnectionRequest provides a mock function with given fields: _a0
func (_m *Kafka) DescribeVpcConnectionRequest(_a0 *kafka.DescribeVpcConnectionInput) (*request.Request, *kafka.DescribeVpcConnectionOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.DescribeVpcConnectionOutput
	if rf, ok := ret.Get(0).(func(*kafka.DescribeVpcConnectionInput) (*request.Request, *kafka.DescribeVpcConnectionOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.DescribeVpcConnectionInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.DescribeVpcConnectionInput) *kafka.DescribeVpcConnectionOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.DescribeVpcConnectionOutput)
		}
	}

	return r0, r1
}

// DescribeVpcConnectionWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) DescribeVpcConnectionWithContext(_a0 context.Context, _a1 *kafka.DescribeVpcConnectionInput, _a2 ...request.Option) (*kafka.DescribeVpcConnectionOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.DescribeVpcConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeVpcConnectionInput, ...request.Option) (*kafka.DescribeVpcConnectionOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.DescribeVpcConnectionInput, ...request.Option) *kafka.DescribeVpcConnectionOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.DescribeVpcConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.DescribeVpcConnectionInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBootstrapBrokers provides a mock function with given fields: _a0
func (_m *Kafka) GetBootstrapBrokers(_a0 *kafka.GetBootstrapBrokersInput) (*kafka.GetBootstrapBrokersOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.GetBootstrapBrokersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.GetBootstrapBrokersInput) (*kafka.GetBootstrapBrokersOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.GetBootstrapBrokersInput) *kafka.GetBootstrapBrokersOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.GetBootstrapBrokersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.GetBootstrapBrokersInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBootstrapBrokersRequest provides a mock function with given fields: _a0
func (_m *Kafka) GetBootstrapBrokersRequest(_a0 *kafka.GetBootstrapBrokersInput) (*request.Request, *kafka.GetBootstrapBrokersOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.GetBootstrapBrokersOutput
	if rf, ok := ret.Get(0).(func(*kafka.GetBootstrapBrokersInput) (*request.Request, *kafka.GetBootstrapBrokersOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.GetBootstrapBrokersInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.GetBootstrapBrokersInput) *kafka.GetBootstrapBrokersOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.GetBootstrapBrokersOutput)
		}
	}

	return r0, r1
}

// GetBootstrapBrokersWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) GetBootstrapBrokersWithContext(_a0 context.Context, _a1 *kafka.GetBootstrapBrokersInput, _a2 ...request.Option) (*kafka.GetBootstrapBrokersOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.GetBootstrapBrokersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.GetBootstrapBrokersInput, ...request.Option) (*kafka.GetBootstrapBrokersOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.GetBootstrapBrokersInput, ...request.Option) *kafka.GetBootstrapBrokersOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.GetBootstrapBrokersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.GetBootstrapBrokersInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterPolicy provides a mock function with given fields: _a0
func (_m *Kafka) GetClusterPolicy(_a0 *kafka.GetClusterPolicyInput) (*kafka.GetClusterPolicyOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.GetClusterPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.GetClusterPolicyInput) (*kafka.GetClusterPolicyOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.GetClusterPolicyInput) *kafka.GetClusterPolicyOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.GetClusterPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.GetClusterPolicyInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterPolicyRequest provides a mock function with given fields: _a0
func (_m *Kafka) GetClusterPolicyRequest(_a0 *kafka.GetClusterPolicyInput) (*request.Request, *kafka.GetClusterPolicyOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.GetClusterPolicyOutput
	if rf, ok := ret.Get(0).(func(*kafka.GetClusterPolicyInput) (*request.Request, *kafka.GetClusterPolicyOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.GetClusterPolicyInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.GetClusterPolicyInput) *kafka.GetClusterPolicyOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.GetClusterPolicyOutput)
		}
	}

	return r0, r1
}

// GetClusterPolicyWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) GetClusterPolicyWithContext(_a0 context.Context, _a1 *kafka.GetClusterPolicyInput, _a2 ...request.Option) (*kafka.GetClusterPolicyOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.GetClusterPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.GetClusterPolicyInput, ...request.Option) (*kafka.GetClusterPolicyOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.GetClusterPolicyInput, ...request.Option) *kafka.GetClusterPolicyOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.GetClusterPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.GetClusterPolicyInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompatibleKafkaVersions provides a mock function with given fields: _a0
func (_m *Kafka) GetCompatibleKafkaVersions(_a0 *kafka.GetCompatibleKafkaVersionsInput) (*kafka.GetCompatibleKafkaVersionsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.GetCompatibleKafkaVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.GetCompatibleKafkaVersionsInput) (*kafka.GetCompatibleKafkaVersionsOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.GetCompatibleKafkaVersionsInput) *kafka.GetCompatibleKafkaVersionsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.GetCompatibleKafkaVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.GetCompatibleKafkaVersionsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompatibleKafkaVersionsRequest provides a mock function with given fields: _a0
func (_m *Kafka) GetCompatibleKafkaVersionsRequest(_a0 *kafka.GetCompatibleKafkaVersionsInput) (*request.Request, *kafka.GetCompatibleKafkaVersionsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.GetCompatibleKafkaVersionsOutput
	if rf, ok := ret.Get(0).(func(*kafka.GetCompatibleKafkaVersionsInput) (*request.Request, *kafka.GetCompatibleKafkaVersionsOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.GetCompatibleKafkaVersionsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.GetCompatibleKafkaVersionsInput) *kafka.GetCompatibleKafkaVersionsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.GetCompatibleKafkaVersionsOutput)
		}
	}

	return r0, r1
}

// GetCompatibleKafkaVersionsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) GetCompatibleKafkaVersionsWithContext(_a0 context.Context, _a1 *kafka.GetCompatibleKafkaVersionsInput, _a2 ...request.Option) (*kafka.GetCompatibleKafkaVersionsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.GetCompatibleKafkaVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.GetCompatibleKafkaVersionsInput, ...request.Option) (*kafka.GetCompatibleKafkaVersionsOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.GetCompatibleKafkaVersionsInput, ...request.Option) *kafka.GetCompatibleKafkaVersionsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.GetCompatibleKafkaVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.GetCompatibleKafkaVersionsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClientVpcConnections provides a mock function with given fields: _a0
func (_m *Kafka) ListClientVpcConnections(_a0 *kafka.ListClientVpcConnectionsInput) (*kafka.ListClientVpcConnectionsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.ListClientVpcConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.ListClientVpcConnectionsInput) (*kafka.ListClientVpcConnectionsOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListClientVpcConnectionsInput) *kafka.ListClientVpcConnectionsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClientVpcConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListClientVpcConnectionsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClientVpcConnectionsPages provides a mock function with given fields: _a0, _a1
func (_m *Kafka) ListClientVpcConnectionsPages(_a0 *kafka.ListClientVpcConnectionsInput, _a1 func(*kafka.ListClientVpcConnectionsOutput, bool) bool) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(*kafka.ListClientVpcConnectionsInput, func(*kafka.ListClientVpcConnectionsOutput, bool) bool) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListClientVpcConnectionsPagesWithContext provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Kafka) ListClientVpcConnectionsPagesWithContext(_a0 context.Context, _a1 *kafka.ListClientVpcConnectionsInput, _a2 func(*kafka.ListClientVpcConnectionsOutput, bool) bool, _a3 ...request.Option) error {
	_va := make([]interface{}, len(_a3))
	for _i := range _a3 {
		_va[_i] = _a3[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1, _a2)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClientVpcConnectionsInput, func(*kafka.ListClientVpcConnectionsOutput, bool) bool, ...request.Option) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListClientVpcConnectionsRequest provides a mock function with given fields: _a0
func (_m *Kafka) ListClientVpcConnectionsRequest(_a0 *kafka.ListClientVpcConnectionsInput) (*request.Request, *kafka.ListClientVpcConnectionsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.ListClientVpcConnectionsOutput
	if rf, ok := ret.Get(0).(func(*kafka.ListClientVpcConnectionsInput) (*request.Request, *kafka.ListClientVpcConnectionsOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListClientVpcConnectionsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListClientVpcConnectionsInput) *kafka.ListClientVpcConnectionsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.ListClientVpcConnectionsOutput)
		}
	}

	return r0, r1
}

// ListClientVpcConnectionsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) ListClientVpcConnectionsWithContext(_a0 context.Context, _a1 *kafka.ListClientVpcConnectionsInput, _a2 ...request.Option) (*kafka.ListClientVpcConnectionsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.ListClientVpcConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClientVpcConnectionsInput, ...request.Option) (*kafka.ListClientVpcConnectionsOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClientVpcConnectionsInput, ...request.Option) *kafka.ListClientVpcConnectionsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClientVpcConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListClientVpcConnectionsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClusterOperations provides a mock function with given fields: _a0
func (_m *Kafka) ListClusterOperations(_a0 *kafka.ListClusterOperationsInput) (*kafka.ListClusterOperationsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.ListClusterOperationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.ListClusterOperationsInput) (*kafka.ListClusterOperationsOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListClusterOperationsInput) *kafka.ListClusterOperationsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClusterOperationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListClusterOperationsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClusterOperationsPages provides a mock function with given fields: _a0, _a1
func (_m *Kafka) ListClusterOperationsPages(_a0 *kafka.ListClusterOperationsInput, _a1 func(*kafka.ListClusterOperationsOutput, bool) bool) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(*kafka.ListClusterOperationsInput, func(*kafka.ListClusterOperationsOutput, bool) bool) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListClusterOperationsPagesWithContext provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Kafka) ListClusterOperationsPagesWithContext(_a0 context.Context, _a1 *kafka.ListClusterOperationsInput, _a2 func(*kafka.ListClusterOperationsOutput, bool) bool, _a3 ...request.Option) error {
	_va := make([]interface{}, len(_a3))
	for _i := range _a3 {
		_va[_i] = _a3[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1, _a2)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClusterOperationsInput, func(*kafka.ListClusterOperationsOutput, bool) bool, ...request.Option) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListClusterOperationsRequest provides a mock function with given fields: _a0
func (_m *Kafka) ListClusterOperationsRequest(_a0 *kafka.ListClusterOperationsInput) (*request.Request, *kafka.ListClusterOperationsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.ListClusterOperationsOutput
	if rf, ok := ret.Get(0).(func(*kafka.ListClusterOperationsInput) (*request.Request, *kafka.ListClusterOperationsOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListClusterOperationsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListClusterOperationsInput) *kafka.ListClusterOperationsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.ListClusterOperationsOutput)
		}
	}

	return r0, r1
}

// ListClusterOperationsV2 provides a mock function with given fields: _a0
func (_m *Kafka) ListClusterOperationsV2(_a0 *kafka.ListClusterOperationsV2Input) (*kafka.ListClusterOperationsV2Output, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.ListClusterOperationsV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.ListClusterOperationsV2Input) (*kafka.ListClusterOperationsV2Output, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListClusterOperationsV2Input) *kafka.ListClusterOperationsV2Output); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClusterOperationsV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListClusterOperationsV2Input) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClusterOperationsV2Pages provides a mock function with given fields: _a0, _a1
func (_m *Kafka) ListClusterOperationsV2Pages(_a0 *kafka.ListClusterOperationsV2Input, _a1 func(*kafka.ListClusterOperationsV2Output, bool) bool) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(*kafka.ListClusterOperationsV2Input, func(*kafka.ListClusterOperationsV2Output, bool) bool) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListClusterOperationsV2PagesWithContext provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Kafka) ListClusterOperationsV2PagesWithContext(_a0 context.Context, _a1 *kafka.ListClusterOperationsV2Input, _a2 func(*kafka.ListClusterOperationsV2Output, bool) bool, _a3 ...request.Option) error {
	_va := make([]interface{}, len(_a3))
	for _i := range _a3 {
		_va[_i] = _a3[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1, _a2)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClusterOperationsV2Input, func(*kafka.ListClusterOperationsV2Output, bool) bool, ...request.Option) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListClusterOperationsV2Request provides a mock function with given fields: _a0
func (_m *Kafka) ListClusterOperationsV2Request(_a0 *kafka.ListClusterOperationsV2Input) (*request.Request, *kafka.ListClusterOperationsV2Output) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.ListClusterOperationsV2Output
	if rf, ok := ret.Get(0).(func(*kafka.ListClusterOperationsV2Input) (*request.Request, *kafka.ListClusterOperationsV2Output)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListClusterOperationsV2Input) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListClusterOperationsV2Input) *kafka.ListClusterOperationsV2Output); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.ListClusterOperationsV2Output)
		}
	}

	return r0, r1
}

// ListClusterOperationsV2WithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) ListClusterOperationsV2WithContext(_a0 context.Context, _a1 *kafka.ListClusterOperationsV2Input, _a2 ...request.Option) (*kafka.ListClusterOperationsV2Output, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.ListClusterOperationsV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClusterOperationsV2Input, ...request.Option) (*kafka.ListClusterOperationsV2Output, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClusterOperationsV2Input, ...request.Option) *kafka.ListClusterOperationsV2Output); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClusterOperationsV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListClusterOperationsV2Input, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClusterOperationsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) ListClusterOperationsWithContext(_a0 context.Context, _a1 *kafka.ListClusterOperationsInput, _a2 ...request.Option) (*kafka.ListClusterOperationsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.ListClusterOperationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClusterOperationsInput, ...request.Option) (*kafka.ListClusterOperationsOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClusterOperationsInput, ...request.Option) *kafka.ListClusterOperationsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClusterOperationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListClusterOperationsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClusters provides a mock function with given fields: _a0
func (_m *Kafka) ListClusters(_a0 *kafka.ListClustersInput) (*kafka.ListClustersOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.ListClustersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.ListClustersInput) (*kafka.ListClustersOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListClustersInput) *kafka.ListClustersOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClustersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListClustersInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClustersPages provides a mock function with given fields: _a0, _a1
func (_m *Kafka) ListClustersPages(_a0 *kafka.ListClustersInput, _a1 func(*kafka.ListClustersOutput, bool) bool) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(*kafka.ListClustersInput, func(*kafka.ListClustersOutput, bool) bool) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListClustersPagesWithContext provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Kafka) ListClustersPagesWithContext(_a0 context.Context, _a1 *kafka.ListClustersInput, _a2 func(*kafka.ListClustersOutput, bool) bool, _a3 ...request.Option) error {
	_va := make([]interface{}, len(_a3))
	for _i := range _a3 {
		_va[_i] = _a3[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1, _a2)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClustersInput, func(*kafka.ListClustersOutput, bool) bool, ...request.Option) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListClustersRequest provides a mock function with given fields: _a0
func (_m *Kafka) ListClustersRequest(_a0 *kafka.ListClustersInput) (*request.Request, *kafka.ListClustersOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.ListClustersOutput
	if rf, ok := ret.Get(0).(func(*kafka.ListClustersInput) (*request.Request, *kafka.ListClustersOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListClustersInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListClustersInput) *kafka.ListClustersOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.ListClustersOutput)
		}
	}

	return r0, r1
}

// ListClustersV2 provides a mock function with given fields: _a0
func (_m *Kafka) ListClustersV2(_a0 *kafka.ListClustersV2Input) (*kafka.ListClustersV2Output, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.ListClustersV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.ListClustersV2Input) (*kafka.ListClustersV2Output, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListClustersV2Input) *kafka.ListClustersV2Output); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClustersV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListClustersV2Input) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClustersV2Pages provides a mock function with given fields: _a0, _a1
func (_m *Kafka) ListClustersV2Pages(_a0 *kafka.ListClustersV2Input, _a1 func(*kafka.ListClustersV2Output, bool) bool) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(*kafka.ListClustersV2Input, func(*kafka.ListClustersV2Output, bool) bool) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListClustersV2PagesWithContext provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Kafka) ListClustersV2PagesWithContext(_a0 context.Context, _a1 *kafka.ListClustersV2Input, _a2 func(*kafka.ListClustersV2Output, bool) bool, _a3 ...request.Option) error {
	_va := make([]interface{}, len(_a3))
	for _i := range _a3 {
		_va[_i] = _a3[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1, _a2)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClustersV2Input, func(*kafka.ListClustersV2Output, bool) bool, ...request.Option) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListClustersV2Request provides a mock function with given fields: _a0
func (_m *Kafka) ListClustersV2Request(_a0 *kafka.ListClustersV2Input) (*request.Request, *kafka.ListClustersV2Output) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.ListClustersV2Output
	if rf, ok := ret.Get(0).(func(*kafka.ListClustersV2Input) (*request.Request, *kafka.ListClustersV2Output)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListClustersV2Input) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListClustersV2Input) *kafka.ListClustersV2Output); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.ListClustersV2Output)
		}
	}

	return r0, r1
}

// ListClustersV2WithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) ListClustersV2WithContext(_a0 context.Context, _a1 *kafka.ListClustersV2Input, _a2 ...request.Option) (*kafka.ListClustersV2Output, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.ListClustersV2Output
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClustersV2Input, ...request.Option) (*kafka.ListClustersV2Output, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClustersV2Input, ...request.Option) *kafka.ListClustersV2Output); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClustersV2Output)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListClustersV2Input, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClustersWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) ListClustersWithContext(_a0 context.Context, _a1 *kafka.ListClustersInput, _a2 ...request.Option) (*kafka.ListClustersOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.ListClustersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClustersInput, ...request.Option) (*kafka.ListClustersOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListClustersInput, ...request.Option) *kafka.ListClustersOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListClustersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListClustersInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConfigurationRevisions provides a mock function with given fields: _a0
func (_m *Kafka) ListConfigurationRevisions(_a0 *kafka.ListConfigurationRevisionsInput) (*kafka.ListConfigurationRevisionsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.ListConfigurationRevisionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.ListConfigurationRevisionsInput) (*kafka.ListConfigurationRevisionsOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListConfigurationRevisionsInput) *kafka.ListConfigurationRevisionsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListConfigurationRevisionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListConfigurationRevisionsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConfigurationRevisionsPages provides a mock function with given fields: _a0, _a1
func (_m *Kafka) ListConfigurationRevisionsPages(_a0 *kafka.ListConfigurationRevisionsInput, _a1 func(*kafka.ListConfigurationRevisionsOutput, bool) bool) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(*kafka.ListConfigurationRevisionsInput, func(*kafka.ListConfigurationRevisionsOutput, bool) bool) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListConfigurationRevisionsPagesWithContext provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Kafka) ListConfigurationRevisionsPagesWithContext(_a0 context.Context, _a1 *kafka.ListConfigurationRevisionsInput, _a2 func(*kafka.ListConfigurationRevisionsOutput, bool) bool, _a3 ...request.Option) error {
	_va := make([]interface{}, len(_a3))
	for _i := range _a3 {
		_va[_i] = _a3[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1, _a2)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListConfigurationRevisionsInput, func(*kafka.ListConfigurationRevisionsOutput, bool) bool, ...request.Option) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListConfigurationRevisionsRequest provides a mock function with given fields: _a0
func (_m *Kafka) ListConfigurationRevisionsRequest(_a0 *kafka.ListConfigurationRevisionsInput) (*request.Request, *kafka.ListConfigurationRevisionsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.ListConfigurationRevisionsOutput
	if rf, ok := ret.Get(0).(func(*kafka.ListConfigurationRevisionsInput) (*request.Request, *kafka.ListConfigurationRevisionsOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListConfigurationRevisionsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListConfigurationRevisionsInput) *kafka.ListConfigurationRevisionsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.ListConfigurationRevisionsOutput)
		}
	}

	return r0, r1
}

// ListConfigurationRevisionsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) ListConfigurationRevisionsWithContext(_a0 context.Context, _a1 *kafka.ListConfigurationRevisionsInput, _a2 ...request.Option) (*kafka.ListConfigurationRevisionsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.ListConfigurationRevisionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListConfigurationRevisionsInput, ...request.Option) (*kafka.ListConfigurationRevisionsOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListConfigurationRevisionsInput, ...request.Option) *kafka.ListConfigurationRevisionsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListConfigurationRevisionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListConfigurationRevisionsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConfigurations provides a mock function with given fields: _a0
func (_m *Kafka) ListConfigurations(_a0 *kafka.ListConfigurationsInput) (*kafka.ListConfigurationsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.ListConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.ListConfigurationsInput) (*kafka.ListConfigurationsOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListConfigurationsInput) *kafka.ListConfigurationsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListConfigurationsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConfigurationsPages provides a mock function with given fields: _a0, _a1
func (_m *Kafka) ListConfigurationsPages(_a0 *kafka.ListConfigurationsInput, _a1 func(*kafka.ListConfigurationsOutput, bool) bool) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(*kafka.ListConfigurationsInput, func(*kafka.ListConfigurationsOutput, bool) bool) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListConfigurationsPagesWithContext provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Kafka) ListConfigurationsPagesWithContext(_a0 context.Context, _a1 *kafka.ListConfigurationsInput, _a2 func(*kafka.ListConfigurationsOutput, bool) bool, _a3 ...request.Option) error {
	_va := make([]interface{}, len(_a3))
	for _i := range _a3 {
		_va[_i] = _a3[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1, _a2)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListConfigurationsInput, func(*kafka.ListConfigurationsOutput, bool) bool, ...request.Option) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListConfigurationsRequest provides a mock function with given fields: _a0
func (_m *Kafka) ListConfigurationsRequest(_a0 *kafka.ListConfigurationsInput) (*request.Request, *kafka.ListConfigurationsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.ListConfigurationsOutput
	if rf, ok := ret.Get(0).(func(*kafka.ListConfigurationsInput) (*request.Request, *kafka.ListConfigurationsOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListConfigurationsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListConfigurationsInput) *kafka.ListConfigurationsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.ListConfigurationsOutput)
		}
	}

	return r0, r1
}

// ListConfigurationsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) ListConfigurationsWithContext(_a0 context.Context, _a1 *kafka.ListConfigurationsInput, _a2 ...request.Option) (*kafka.ListConfigurationsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.ListConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListConfigurationsInput, ...request.Option) (*kafka.ListConfigurationsOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListConfigurationsInput, ...request.Option) *kafka.ListConfigurationsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListConfigurationsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKafkaVersions provides a mock function with given fields: _a0
func (_m *Kafka) ListKafkaVersions(_a0 *kafka.ListKafkaVersionsInput) (*kafka.ListKafkaVersionsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.ListKafkaVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.ListKafkaVersionsInput) (*kafka.ListKafkaVersionsOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListKafkaVersionsInput) *kafka.ListKafkaVersionsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListKafkaVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListKafkaVersionsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKafkaVersionsPages provides a mock function with given fields: _a0, _a1
func (_m *Kafka) ListKafkaVersionsPages(_a0 *kafka.ListKafkaVersionsInput, _a1 func(*kafka.ListKafkaVersionsOutput, bool) bool) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(*kafka.ListKafkaVersionsInput, func(*kafka.ListKafkaVersionsOutput, bool) bool) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListKafkaVersionsPagesWithContext provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Kafka) ListKafkaVersionsPagesWithContext(_a0 context.Context, _a1 *kafka.ListKafkaVersionsInput, _a2 func(*kafka.ListKafkaVersionsOutput, bool) bool, _a3 ...request.Option) error {
	_va := make([]interface{}, len(_a3))
	for _i := range _a3 {
		_va[_i] = _a3[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1, _a2)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListKafkaVersionsInput, func(*kafka.ListKafkaVersionsOutput, bool) bool, ...request.Option) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListKafkaVersionsRequest provides a mock function with given fields: _a0
func (_m *Kafka) ListKafkaVersionsRequest(_a0 *kafka.ListKafkaVersionsInput) (*request.Request, *kafka.ListKafkaVersionsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.ListKafkaVersionsOutput
	if rf, ok := ret.Get(0).(func(*kafka.ListKafkaVersionsInput) (*request.Request, *kafka.ListKafkaVersionsOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListKafkaVersionsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListKafkaVersionsInput) *kafka.ListKafkaVersionsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.ListKafkaVersionsOutput)
		}
	}

	return r0, r1
}

// ListKafkaVersionsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) ListKafkaVersionsWithContext(_a0 context.Context, _a1 *kafka.ListKafkaVersionsInput, _a2 ...request.Option) (*kafka.ListKafkaVersionsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.ListKafkaVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListKafkaVersionsInput, ...request.Option) (*kafka.ListKafkaVersionsOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListKafkaVersionsInput, ...request.Option) *kafka.ListKafkaVersionsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListKafkaVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListKafkaVersionsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNodes provides a mock function with given fields: _a0
func (_m *Kafka) ListNodes(_a0 *kafka.ListNodesInput) (*kafka.ListNodesOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.ListNodesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.ListNodesInput) (*kafka.ListNodesOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListNodesInput) *kafka.ListNodesOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListNodesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListNodesInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNodesPages provides a mock function with given fields: _a0, _a1
func (_m *Kafka) ListNodesPages(_a0 *kafka.ListNodesInput, _a1 func(*kafka.ListNodesOutput, bool) bool) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(*kafka.ListNodesInput, func(*kafka.ListNodesOutput, bool) bool) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListNodesPagesWithContext provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Kafka) ListNodesPagesWithContext(_a0 context.Context, _a1 *kafka.ListNodesInput, _a2 func(*kafka.ListNodesOutput, bool) bool, _a3 ...request.Option) error {
	_va := make([]interface{}, len(_a3))
	for _i := range _a3 {
		_va[_i] = _a3[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1, _a2)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListNodesInput, func(*kafka.ListNodesOutput, bool) bool, ...request.Option) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListNodesRequest provides a mock function with given fields: _a0
func (_m *Kafka) ListNodesRequest(_a0 *kafka.ListNodesInput) (*request.Request, *kafka.ListNodesOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.ListNodesOutput
	if rf, ok := ret.Get(0).(func(*kafka.ListNodesInput) (*request.Request, *kafka.ListNodesOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListNodesInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListNodesInput) *kafka.ListNodesOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.ListNodesOutput)
		}
	}

	return r0, r1
}

// ListNodesWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) ListNodesWithContext(_a0 context.Context, _a1 *kafka.ListNodesInput, _a2 ...request.Option) (*kafka.ListNodesOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.ListNodesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListNodesInput, ...request.Option) (*kafka.ListNodesOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListNodesInput, ...request.Option) *kafka.ListNodesOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListNodesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListNodesInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListScramSecrets provides a mock function with given fields: _a0
func (_m *Kafka) ListScramSecrets(_a0 *kafka.ListScramSecretsInput) (*kafka.ListScramSecretsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.ListScramSecretsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.ListScramSecretsInput) (*kafka.ListScramSecretsOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListScramSecretsInput) *kafka.ListScramSecretsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListScramSecretsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListScramSecretsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListScramSecretsPages provides a mock function with given fields: _a0, _a1
func (_m *Kafka) ListScramSecretsPages(_a0 *kafka.ListScramSecretsInput, _a1 func(*kafka.ListScramSecretsOutput, bool) bool) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(*kafka.ListScramSecretsInput, func(*kafka.ListScramSecretsOutput, bool) bool) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListScramSecretsPagesWithContext provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Kafka) ListScramSecretsPagesWithContext(_a0 context.Context, _a1 *kafka.ListScramSecretsInput, _a2 func(*kafka.ListScramSecretsOutput, bool) bool, _a3 ...request.Option) error {
	_va := make([]interface{}, len(_a3))
	for _i := range _a3 {
		_va[_i] = _a3[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1, _a2)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListScramSecretsInput, func(*kafka.ListScramSecretsOutput, bool) bool, ...request.Option) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListScramSecretsRequest provides a mock function with given fields: _a0
func (_m *Kafka) ListScramSecretsRequest(_a0 *kafka.ListScramSecretsInput) (*request.Request, *kafka.ListScramSecretsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.ListScramSecretsOutput
	if rf, ok := ret.Get(0).(func(*kafka.ListScramSecretsInput) (*request.Request, *kafka.ListScramSecretsOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListScramSecretsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListScramSecretsInput) *kafka.ListScramSecretsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.ListScramSecretsOutput)
		}
	}

	return r0, r1
}

// ListScramSecretsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) ListScramSecretsWithContext(_a0 context.Context, _a1 *kafka.ListScramSecretsInput, _a2 ...request.Option) (*kafka.ListScramSecretsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.ListScramSecretsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListScramSecretsInput, ...request.Option) (*kafka.ListScramSecretsOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListScramSecretsInput, ...request.Option) *kafka.ListScramSecretsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListScramSecretsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListScramSecretsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: _a0
func (_m *Kafka) ListTagsForResource(_a0 *kafka.ListTagsForResourceInput) (*kafka.ListTagsForResourceOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.ListTagsForResourceInput) (*kafka.ListTagsForResourceOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListTagsForResourceInput) *kafka.ListTagsForResourceOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListTagsForResourceInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResourceRequest provides a mock function with given fields: _a0
func (_m *Kafka) ListTagsForResourceRequest(_a0 *kafka.ListTagsForResourceInput) (*request.Request, *kafka.ListTagsForResourceOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.ListTagsForResourceOutput
	if rf, ok := ret.Get(0).(func(*kafka.ListTagsForResourceInput) (*request.Request, *kafka.ListTagsForResourceOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListTagsForResourceInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListTagsForResourceInput) *kafka.ListTagsForResourceOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.ListTagsForResourceOutput)
		}
	}

	return r0, r1
}

// ListTagsForResourceWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) ListTagsForResourceWithContext(_a0 context.Context, _a1 *kafka.ListTagsForResourceInput, _a2 ...request.Option) (*kafka.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListTagsForResourceInput, ...request.Option) (*kafka.ListTagsForResourceOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListTagsForResourceInput, ...request.Option) *kafka.ListTagsForResourceOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListTagsForResourceInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVpcConnections provides a mock function with given fields: _a0
func (_m *Kafka) ListVpcConnections(_a0 *kafka.ListVpcConnectionsInput) (*kafka.ListVpcConnectionsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.ListVpcConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.ListVpcConnectionsInput) (*kafka.ListVpcConnectionsOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListVpcConnectionsInput) *kafka.ListVpcConnectionsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListVpcConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListVpcConnectionsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVpcConnectionsPages provides a mock function with given fields: _a0, _a1
func (_m *Kafka) ListVpcConnectionsPages(_a0 *kafka.ListVpcConnectionsInput, _a1 func(*kafka.ListVpcConnectionsOutput, bool) bool) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(*kafka.ListVpcConnectionsInput, func(*kafka.ListVpcConnectionsOutput, bool) bool) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListVpcConnectionsPagesWithContext provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *Kafka) ListVpcConnectionsPagesWithContext(_a0 context.Context, _a1 *kafka.ListVpcConnectionsInput, _a2 func(*kafka.ListVpcConnectionsOutput, bool) bool, _a3 ...request.Option) error {
	_va := make([]interface{}, len(_a3))
	for _i := range _a3 {
		_va[_i] = _a3[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1, _a2)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListVpcConnectionsInput, func(*kafka.ListVpcConnectionsOutput, bool) bool, ...request.Option) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListVpcConnectionsRequest provides a mock function with given fields: _a0
func (_m *Kafka) ListVpcConnectionsRequest(_a0 *kafka.ListVpcConnectionsInput) (*request.Request, *kafka.ListVpcConnectionsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.ListVpcConnectionsOutput
	if rf, ok := ret.Get(0).(func(*kafka.ListVpcConnectionsInput) (*request.Request, *kafka.ListVpcConnectionsOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.ListVpcConnectionsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.ListVpcConnectionsInput) *kafka.ListVpcConnectionsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.ListVpcConnectionsOutput)
		}
	}

	return r0, r1
}

// ListVpcConnectionsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) ListVpcConnectionsWithContext(_a0 context.Context, _a1 *kafka.ListVpcConnectionsInput, _a2 ...request.Option) (*kafka.ListVpcConnectionsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.ListVpcConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListVpcConnectionsInput, ...request.Option) (*kafka.ListVpcConnectionsOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.ListVpcConnectionsInput, ...request.Option) *kafka.ListVpcConnectionsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ListVpcConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.ListVpcConnectionsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutClusterPolicy provides a mock function with given fields: _a0
func (_m *Kafka) PutClusterPolicy(_a0 *kafka.PutClusterPolicyInput) (*kafka.PutClusterPolicyOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.PutClusterPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.PutClusterPolicyInput) (*kafka.PutClusterPolicyOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.PutClusterPolicyInput) *kafka.PutClusterPolicyOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.PutClusterPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.PutClusterPolicyInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutClusterPolicyRequest provides a mock function with given fields: _a0
func (_m *Kafka) PutClusterPolicyRequest(_a0 *kafka.PutClusterPolicyInput) (*request.Request, *kafka.PutClusterPolicyOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.PutClusterPolicyOutput
	if rf, ok := ret.Get(0).(func(*kafka.PutClusterPolicyInput) (*request.Request, *kafka.PutClusterPolicyOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.PutClusterPolicyInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.PutClusterPolicyInput) *kafka.PutClusterPolicyOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.PutClusterPolicyOutput)
		}
	}

	return r0, r1
}

// PutClusterPolicyWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) PutClusterPolicyWithContext(_a0 context.Context, _a1 *kafka.PutClusterPolicyInput, _a2 ...request.Option) (*kafka.PutClusterPolicyOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.PutClusterPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.PutClusterPolicyInput, ...request.Option) (*kafka.PutClusterPolicyOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.PutClusterPolicyInput, ...request.Option) *kafka.PutClusterPolicyOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.PutClusterPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.PutClusterPolicyInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RebootBroker provides a mock function with given fields: _a0
func (_m *Kafka) RebootBroker(_a0 *kafka.RebootBrokerInput) (*kafka.RebootBrokerOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.RebootBrokerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.RebootBrokerInput) (*kafka.RebootBrokerOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.RebootBrokerInput) *kafka.RebootBrokerOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.RebootBrokerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.RebootBrokerInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RebootBrokerRequest provides a mock function with given fields: _a0
func (_m *Kafka) RebootBrokerRequest(_a0 *kafka.RebootBrokerInput) (*request.Request, *kafka.RebootBrokerOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.RebootBrokerOutput
	if rf, ok := ret.Get(0).(func(*kafka.RebootBrokerInput) (*request.Request, *kafka.RebootBrokerOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.RebootBrokerInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.RebootBrokerInput) *kafka.RebootBrokerOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.RebootBrokerOutput)
		}
	}

	return r0, r1
}

// RebootBrokerWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) RebootBrokerWithContext(_a0 context.Context, _a1 *kafka.RebootBrokerInput, _a2 ...request.Option) (*kafka.RebootBrokerOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.RebootBrokerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.RebootBrokerInput, ...request.Option) (*kafka.RebootBrokerOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.RebootBrokerInput, ...request.Option) *kafka.RebootBrokerOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.RebootBrokerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.RebootBrokerInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectClientVpcConnection provides a mock function with given fields: _a0
func (_m *Kafka) RejectClientVpcConnection(_a0 *kafka.RejectClientVpcConnectionInput) (*kafka.RejectClientVpcConnectionOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.RejectClientVpcConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.RejectClientVpcConnectionInput) (*kafka.RejectClientVpcConnectionOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.RejectClientVpcConnectionInput) *kafka.RejectClientVpcConnectionOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.RejectClientVpcConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.RejectClientVpcConnectionInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectClientVpcConnectionRequest provides a mock function with given fields: _a0
func (_m *Kafka) RejectClientVpcConnectionRequest(_a0 *kafka.RejectClientVpcConnectionInput) (*request.Request, *kafka.RejectClientVpcConnectionOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.RejectClientVpcConnectionOutput
	if rf, ok := ret.Get(0).(func(*kafka.RejectClientVpcConnectionInput) (*request.Request, *kafka.RejectClientVpcConnectionOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.RejectClientVpcConnectionInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.RejectClientVpcConnectionInput) *kafka.RejectClientVpcConnectionOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.RejectClientVpcConnectionOutput)
		}
	}

	return r0, r1
}

// RejectClientVpcConnectionWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) RejectClientVpcConnectionWithContext(_a0 context.Context, _a1 *kafka.RejectClientVpcConnectionInput, _a2 ...request.Option) (*kafka.RejectClientVpcConnectionOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.RejectClientVpcConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.RejectClientVpcConnectionInput, ...request.Option) (*kafka.RejectClientVpcConnectionOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.RejectClientVpcConnectionInput, ...request.Option) *kafka.RejectClientVpcConnectionOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.RejectClientVpcConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.RejectClientVpcConnectionInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: _a0
func (_m *Kafka) TagResource(_a0 *kafka.TagResourceInput) (*kafka.TagResourceOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.TagResourceInput) (*kafka.TagResourceOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.TagResourceInput) *kafka.TagResourceOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.TagResourceInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResourceRequest provides a mock function with given fields: _a0
func (_m *Kafka) TagResourceRequest(_a0 *kafka.TagResourceInput) (*request.Request, *kafka.TagResourceOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.TagResourceOutput
	if rf, ok := ret.Get(0).(func(*kafka.TagResourceInput) (*request.Request, *kafka.TagResourceOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.TagResourceInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.TagResourceInput) *kafka.TagResourceOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.TagResourceOutput)
		}
	}

	return r0, r1
}

// TagResourceWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) TagResourceWithContext(_a0 context.Context, _a1 *kafka.TagResourceInput, _a2 ...request.Option) (*kafka.TagResourceOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.TagResourceInput, ...request.Option) (*kafka.TagResourceOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.TagResourceInput, ...request.Option) *kafka.TagResourceOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.TagResourceInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: _a0
func (_m *Kafka) UntagResource(_a0 *kafka.UntagResourceInput) (*kafka.UntagResourceOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.UntagResourceInput) (*kafka.UntagResourceOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UntagResourceInput) *kafka.UntagResourceOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UntagResourceInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResourceRequest provides a mock function with given fields: _a0
func (_m *Kafka) UntagResourceRequest(_a0 *kafka.UntagResourceInput) (*request.Request, *kafka.UntagResourceOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.UntagResourceOutput
	if rf, ok := ret.Get(0).(func(*kafka.UntagResourceInput) (*request.Request, *kafka.UntagResourceOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UntagResourceInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UntagResourceInput) *kafka.UntagResourceOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.UntagResourceOutput)
		}
	}

	return r0, r1
}

// UntagResourceWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) UntagResourceWithContext(_a0 context.Context, _a1 *kafka.UntagResourceInput, _a2 ...request.Option) (*kafka.UntagResourceOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UntagResourceInput, ...request.Option) (*kafka.UntagResourceOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UntagResourceInput, ...request.Option) *kafka.UntagResourceOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UntagResourceInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBrokerCount provides a mock function with given fields: _a0
func (_m *Kafka) UpdateBrokerCount(_a0 *kafka.UpdateBrokerCountInput) (*kafka.UpdateBrokerCountOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.UpdateBrokerCountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.UpdateBrokerCountInput) (*kafka.UpdateBrokerCountOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateBrokerCountInput) *kafka.UpdateBrokerCountOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateBrokerCountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateBrokerCountInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBrokerCountRequest provides a mock function with given fields: _a0
func (_m *Kafka) UpdateBrokerCountRequest(_a0 *kafka.UpdateBrokerCountInput) (*request.Request, *kafka.UpdateBrokerCountOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.UpdateBrokerCountOutput
	if rf, ok := ret.Get(0).(func(*kafka.UpdateBrokerCountInput) (*request.Request, *kafka.UpdateBrokerCountOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateBrokerCountInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateBrokerCountInput) *kafka.UpdateBrokerCountOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.UpdateBrokerCountOutput)
		}
	}

	return r0, r1
}

// UpdateBrokerCountWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) UpdateBrokerCountWithContext(_a0 context.Context, _a1 *kafka.UpdateBrokerCountInput, _a2 ...request.Option) (*kafka.UpdateBrokerCountOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.UpdateBrokerCountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateBrokerCountInput, ...request.Option) (*kafka.UpdateBrokerCountOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateBrokerCountInput, ...request.Option) *kafka.UpdateBrokerCountOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateBrokerCountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateBrokerCountInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBrokerStorage provides a mock function with given fields: _a0
func (_m *Kafka) UpdateBrokerStorage(_a0 *kafka.UpdateBrokerStorageInput) (*kafka.UpdateBrokerStorageOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.UpdateBrokerStorageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.UpdateBrokerStorageInput) (*kafka.UpdateBrokerStorageOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateBrokerStorageInput) *kafka.UpdateBrokerStorageOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateBrokerStorageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateBrokerStorageInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBrokerStorageRequest provides a mock function with given fields: _a0
func (_m *Kafka) UpdateBrokerStorageRequest(_a0 *kafka.UpdateBrokerStorageInput) (*request.Request, *kafka.UpdateBrokerStorageOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.UpdateBrokerStorageOutput
	if rf, ok := ret.Get(0).(func(*kafka.UpdateBrokerStorageInput) (*request.Request, *kafka.UpdateBrokerStorageOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateBrokerStorageInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateBrokerStorageInput) *kafka.UpdateBrokerStorageOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.UpdateBrokerStorageOutput)
		}
	}

	return r0, r1
}

// UpdateBrokerStorageWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) UpdateBrokerStorageWithContext(_a0 context.Context, _a1 *kafka.UpdateBrokerStorageInput, _a2 ...request.Option) (*kafka.UpdateBrokerStorageOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.UpdateBrokerStorageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateBrokerStorageInput, ...request.Option) (*kafka.UpdateBrokerStorageOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateBrokerStorageInput, ...request.Option) *kafka.UpdateBrokerStorageOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateBrokerStorageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateBrokerStorageInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBrokerType provides a mock function with given fields: _a0
func (_m *Kafka) UpdateBrokerType(_a0 *kafka.UpdateBrokerTypeInput) (*kafka.UpdateBrokerTypeOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.UpdateBrokerTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.UpdateBrokerTypeInput) (*kafka.UpdateBrokerTypeOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateBrokerTypeInput) *kafka.UpdateBrokerTypeOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateBrokerTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateBrokerTypeInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBrokerTypeRequest provides a mock function with given fields: _a0
func (_m *Kafka) UpdateBrokerTypeRequest(_a0 *kafka.UpdateBrokerTypeInput) (*request.Request, *kafka.UpdateBrokerTypeOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.UpdateBrokerTypeOutput
	if rf, ok := ret.Get(0).(func(*kafka.UpdateBrokerTypeInput) (*request.Request, *kafka.UpdateBrokerTypeOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateBrokerTypeInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateBrokerTypeInput) *kafka.UpdateBrokerTypeOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.UpdateBrokerTypeOutput)
		}
	}

	return r0, r1
}

// UpdateBrokerTypeWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) UpdateBrokerTypeWithContext(_a0 context.Context, _a1 *kafka.UpdateBrokerTypeInput, _a2 ...request.Option) (*kafka.UpdateBrokerTypeOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.UpdateBrokerTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateBrokerTypeInput, ...request.Option) (*kafka.UpdateBrokerTypeOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateBrokerTypeInput, ...request.Option) *kafka.UpdateBrokerTypeOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateBrokerTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateBrokerTypeInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateClusterConfiguration provides a mock function with given fields: _a0
func (_m *Kafka) UpdateClusterConfiguration(_a0 *kafka.UpdateClusterConfigurationInput) (*kafka.UpdateClusterConfigurationOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.UpdateClusterConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.UpdateClusterConfigurationInput) (*kafka.UpdateClusterConfigurationOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateClusterConfigurationInput) *kafka.UpdateClusterConfigurationOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateClusterConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateClusterConfigurationInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateClusterConfigurationRequest provides a mock function with given fields: _a0
func (_m *Kafka) UpdateClusterConfigurationRequest(_a0 *kafka.UpdateClusterConfigurationInput) (*request.Request, *kafka.UpdateClusterConfigurationOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.UpdateClusterConfigurationOutput
	if rf, ok := ret.Get(0).(func(*kafka.UpdateClusterConfigurationInput) (*request.Request, *kafka.UpdateClusterConfigurationOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateClusterConfigurationInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateClusterConfigurationInput) *kafka.UpdateClusterConfigurationOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.UpdateClusterConfigurationOutput)
		}
	}

	return r0, r1
}

// UpdateClusterConfigurationWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) UpdateClusterConfigurationWithContext(_a0 context.Context, _a1 *kafka.UpdateClusterConfigurationInput, _a2 ...request.Option) (*kafka.UpdateClusterConfigurationOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.UpdateClusterConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateClusterConfigurationInput, ...request.Option) (*kafka.UpdateClusterConfigurationOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateClusterConfigurationInput, ...request.Option) *kafka.UpdateClusterConfigurationOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateClusterConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateClusterConfigurationInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateClusterKafkaVersion provides a mock function with given fields: _a0
func (_m *Kafka) UpdateClusterKafkaVersion(_a0 *kafka.UpdateClusterKafkaVersionInput) (*kafka.UpdateClusterKafkaVersionOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.UpdateClusterKafkaVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.UpdateClusterKafkaVersionInput) (*kafka.UpdateClusterKafkaVersionOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateClusterKafkaVersionInput) *kafka.UpdateClusterKafkaVersionOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateClusterKafkaVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateClusterKafkaVersionInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateClusterKafkaVersionRequest provides a mock function with given fields: _a0
func (_m *Kafka) UpdateClusterKafkaVersionRequest(_a0 *kafka.UpdateClusterKafkaVersionInput) (*request.Request, *kafka.UpdateClusterKafkaVersionOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.UpdateClusterKafkaVersionOutput
	if rf, ok := ret.Get(0).(func(*kafka.UpdateClusterKafkaVersionInput) (*request.Request, *kafka.UpdateClusterKafkaVersionOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateClusterKafkaVersionInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateClusterKafkaVersionInput) *kafka.UpdateClusterKafkaVersionOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.UpdateClusterKafkaVersionOutput)
		}
	}

	return r0, r1
}

// UpdateClusterKafkaVersionWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) UpdateClusterKafkaVersionWithContext(_a0 context.Context, _a1 *kafka.UpdateClusterKafkaVersionInput, _a2 ...request.Option) (*kafka.UpdateClusterKafkaVersionOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.UpdateClusterKafkaVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateClusterKafkaVersionInput, ...request.Option) (*kafka.UpdateClusterKafkaVersionOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateClusterKafkaVersionInput, ...request.Option) *kafka.UpdateClusterKafkaVersionOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateClusterKafkaVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateClusterKafkaVersionInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConfiguration provides a mock function with given fields: _a0
func (_m *Kafka) UpdateConfiguration(_a0 *kafka.UpdateConfigurationInput) (*kafka.UpdateConfigurationOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.UpdateConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.UpdateConfigurationInput) (*kafka.UpdateConfigurationOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateConfigurationInput) *kafka.UpdateConfigurationOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateConfigurationInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConfigurationRequest provides a mock function with given fields: _a0
func (_m *Kafka) UpdateConfigurationRequest(_a0 *kafka.UpdateConfigurationInput) (*request.Request, *kafka.UpdateConfigurationOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.UpdateConfigurationOutput
	if rf, ok := ret.Get(0).(func(*kafka.UpdateConfigurationInput) (*request.Request, *kafka.UpdateConfigurationOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateConfigurationInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateConfigurationInput) *kafka.UpdateConfigurationOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.UpdateConfigurationOutput)
		}
	}

	return r0, r1
}

// UpdateConfigurationWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) UpdateConfigurationWithContext(_a0 context.Context, _a1 *kafka.UpdateConfigurationInput, _a2 ...request.Option) (*kafka.UpdateConfigurationOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.UpdateConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateConfigurationInput, ...request.Option) (*kafka.UpdateConfigurationOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateConfigurationInput, ...request.Option) *kafka.UpdateConfigurationOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateConfigurationInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConnectivity provides a mock function with given fields: _a0
func (_m *Kafka) UpdateConnectivity(_a0 *kafka.UpdateConnectivityInput) (*kafka.UpdateConnectivityOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.UpdateConnectivityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.UpdateConnectivityInput) (*kafka.UpdateConnectivityOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateConnectivityInput) *kafka.UpdateConnectivityOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateConnectivityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateConnectivityInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConnectivityRequest provides a mock function with given fields: _a0
func (_m *Kafka) UpdateConnectivityRequest(_a0 *kafka.UpdateConnectivityInput) (*request.Request, *kafka.UpdateConnectivityOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.UpdateConnectivityOutput
	if rf, ok := ret.Get(0).(func(*kafka.UpdateConnectivityInput) (*request.Request, *kafka.UpdateConnectivityOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateConnectivityInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateConnectivityInput) *kafka.UpdateConnectivityOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.UpdateConnectivityOutput)
		}
	}

	return r0, r1
}

// UpdateConnectivityWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) UpdateConnectivityWithContext(_a0 context.Context, _a1 *kafka.UpdateConnectivityInput, _a2 ...request.Option) (*kafka.UpdateConnectivityOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.UpdateConnectivityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateConnectivityInput, ...request.Option) (*kafka.UpdateConnectivityOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateConnectivityInput, ...request.Option) *kafka.UpdateConnectivityOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateConnectivityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateConnectivityInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMonitoring provides a mock function with given fields: _a0
func (_m *Kafka) UpdateMonitoring(_a0 *kafka.UpdateMonitoringInput) (*kafka.UpdateMonitoringOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.UpdateMonitoringOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.UpdateMonitoringInput) (*kafka.UpdateMonitoringOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateMonitoringInput) *kafka.UpdateMonitoringOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateMonitoringOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateMonitoringInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMonitoringRequest provides a mock function with given fields: _a0
func (_m *Kafka) UpdateMonitoringRequest(_a0 *kafka.UpdateMonitoringInput) (*request.Request, *kafka.UpdateMonitoringOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.UpdateMonitoringOutput
	if rf, ok := ret.Get(0).(func(*kafka.UpdateMonitoringInput) (*request.Request, *kafka.UpdateMonitoringOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateMonitoringInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateMonitoringInput) *kafka.UpdateMonitoringOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.UpdateMonitoringOutput)
		}
	}

	return r0, r1
}

// UpdateMonitoringWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) UpdateMonitoringWithContext(_a0 context.Context, _a1 *kafka.UpdateMonitoringInput, _a2 ...request.Option) (*kafka.UpdateMonitoringOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.UpdateMonitoringOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateMonitoringInput, ...request.Option) (*kafka.UpdateMonitoringOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateMonitoringInput, ...request.Option) *kafka.UpdateMonitoringOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateMonitoringOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateMonitoringInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSecurity provides a mock function with given fields: _a0
func (_m *Kafka) UpdateSecurity(_a0 *kafka.UpdateSecurityInput) (*kafka.UpdateSecurityOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.UpdateSecurityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.UpdateSecurityInput) (*kafka.UpdateSecurityOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateSecurityInput) *kafka.UpdateSecurityOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateSecurityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateSecurityInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSecurityRequest provides a mock function with given fields: _a0
func (_m *Kafka) UpdateSecurityRequest(_a0 *kafka.UpdateSecurityInput) (*request.Request, *kafka.UpdateSecurityOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.UpdateSecurityOutput
	if rf, ok := ret.Get(0).(func(*kafka.UpdateSecurityInput) (*request.Request, *kafka.UpdateSecurityOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateSecurityInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateSecurityInput) *kafka.UpdateSecurityOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.UpdateSecurityOutput)
		}
	}

	return r0, r1
}

// UpdateSecurityWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) UpdateSecurityWithContext(_a0 context.Context, _a1 *kafka.UpdateSecurityInput, _a2 ...request.Option) (*kafka.UpdateSecurityOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.UpdateSecurityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateSecurityInput, ...request.Option) (*kafka.UpdateSecurityOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateSecurityInput, ...request.Option) *kafka.UpdateSecurityOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateSecurityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateSecurityInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStorage provides a mock function with given fields: _a0
func (_m *Kafka) UpdateStorage(_a0 *kafka.UpdateStorageInput) (*kafka.UpdateStorageOutput, error) {
	ret := _m.Called(_a0)

	var r0 *kafka.UpdateStorageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*kafka.UpdateStorageInput) (*kafka.UpdateStorageOutput, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateStorageInput) *kafka.UpdateStorageOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateStorageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateStorageInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStorageRequest provides a mock function with given fields: _a0
func (_m *Kafka) UpdateStorageRequest(_a0 *kafka.UpdateStorageInput) (*request.Request, *kafka.UpdateStorageOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	var r1 *kafka.UpdateStorageOutput
	if rf, ok := ret.Get(0).(func(*kafka.UpdateStorageInput) (*request.Request, *kafka.UpdateStorageOutput)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*kafka.UpdateStorageInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(*kafka.UpdateStorageInput) *kafka.UpdateStorageOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*kafka.UpdateStorageOutput)
		}
	}

	return r0, r1
}

// UpdateStorageWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *Kafka) UpdateStorageWithContext(_a0 context.Context, _a1 *kafka.UpdateStorageInput, _a2 ...request.Option) (*kafka.UpdateStorageOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *kafka.UpdateStorageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateStorageInput, ...request.Option) (*kafka.UpdateStorageOutput, error)); ok {
		return rf(_a0, _a1, _a2...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kafka.UpdateStorageInput, ...request.Option) *kafka.UpdateStorageOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.UpdateStorageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kafka.UpdateStorageInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewKafka interface {
	mock.TestingT
	Cleanup(func())
}

// NewKafka creates a new instance of Kafka. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewKafka(t mockConstructorTestingTNewKafka) *Kafka {
	mock := &Kafka{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
