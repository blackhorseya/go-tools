package randm

import (
	"errors"
	"math/rand"
	"sync"
	"time"
)

const (
	// encodeBaseChars as randome generate string based RID dicrionary, However, removed uppercase I and O is to avoid
	// generate string confuse user, so, it wouldn't have 1 or I, 0 or O quesion
	encodeBaseChars = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
)

var decodeBaseMap [256]byte

// NewDice is the constructor to new randm.Method
func NewDice(node int64) Method {
	go genInt()
	go genInt64()
	for i := 0; i < len(decodeBaseMap); i++ {
		decodeBaseMap[i] = 0xFF
	}

	for i := 0; i < len(encodeBaseChars); i++ {
		decodeBaseMap[encodeBaseChars[i]] = byte(i)
	}

	mu.Lock()
	nodeMax = -1 ^ (-1 << nodeBits)
	nodeMask = nodeMax << stepBits
	stepMask = -1 ^ (-1 << stepBits)
	timeShift = nodeBits + stepBits
	nodeShift = stepBits
	defer mu.Unlock()

	if node < 0 {
		node = 1
	}

	if node > nodeMax {
		node = nodeMax
	}

	baseTime, _ := time.Parse("2006-01-02T15:04:05-07:00", "2021-06-15T01:06:08+00:00")
	nowTimeMs := time.Now().UnixNano() / int64(time.Millisecond)

	d := &dice{
		baseTime:      baseTime,
		currentTimeMs: nowTimeMs,
		node:          node,
		nodeMax:       nodeMax,
		timeShift:     timeShift,
		nodeShift:     nodeShift,
		nodeMask:      nodeMask,
		stepMask:      stepMask,
		step:          0,
	}

	return d
}

var (
	chInt   = make(chan int, 10000)
	chInt64 = make(chan int64, 10000)

	mu        sync.Mutex
	nodeBits  uint8 = 10
	stepBits  uint8 = 12
	nodeMax   int64
	nodeMask  int64
	stepMask  int64
	timeShift = nodeBits + stepBits
	nodeShift = stepBits
)

var (
	ErrInvalidBaseByte = errors.New("invalid base byte")
)

// genInt generates integer into channel to prevent concurrent access of rand function.
// See https://groups.google.com/forum/#!topic/golang-nuts/oyTWypHlHog for details. (// here is the issue from about year 2015, it might be solved but need to check)
// both genInt and genInt64
func genInt() {
	// source is not safe for concurrent use by multiple goroutines, so we create
	// it for each goroutine.
	s := rand.New(rand.NewSource(time.Now().UnixNano()))
	for {
		chInt <- s.Int()
	}
}

func genInt64() {
	s := rand.New(rand.NewSource(time.Now().UnixNano()))
	for {
		chInt64 <- s.Int63()
	}
}

// Dice is the rand foundation parameters
type dice struct {
	mu            sync.Mutex
	baseTime      time.Time
	currentTimeMs int64
	node          int64
	nodeMax       int64
	nodeMask      int64
	step          int64
	stepMask      int64
	timeShift     uint8
	nodeShift     uint8
}

// RID is custom type random ID, by default, ID will be generated as uint64 number,
// but we also can applied it as foundation with attached mehtods to expends its applications
type RID int64

/**!SECTION
RID seems random but can be regenerated by "same condition", same variance with same context.
We need it to be digital but randome enough but also can be verify
*/

// GenerateRID to geenrate RID
func (d *dice) GenerateRID() RID {
	d.mu.Lock()
	defer d.mu.Unlock()

	if d.step == 9999 {
		d.step = 0
	}

	nowTimeMs := time.Now().UnixNano() / int64(time.Millisecond)
	if nowTimeMs >= d.currentTimeMs {
		d.step = (d.step + 1) & d.stepMask
	}
	diffMs := nowTimeMs - (d.baseTime.UnixNano() / int64(time.Millisecond))

	rid := RID((diffMs)<<d.timeShift |
		(d.node << int64(d.nodeShift)) |
		(d.step),
	)

	return rid
}

// IsValidateRID for quick check is input RID is avalidate RID
func (d *dice) IsValidateRID(rid int64) (res bool) {
	d.mu.Lock()
	defer d.mu.Unlock()
	// base time is 2000/01/1 Jan 01 00:00:00-UTC+0
	baseTimeDiff := d.baseTime.UnixMilli() - (d.baseTime.UnixNano() / int64(time.Millisecond))
	baseRID := RID((baseTimeDiff)<<int64(d.timeShift) | (d.node << int64(d.nodeShift)) | d.step)

	currentTimeDiff := time.Now().UnixMilli() - (d.baseTime.UnixNano() / int64(time.Millisecond))
	currentRID := RID((currentTimeDiff)<<int64(d.timeShift) | (d.node << int64(d.nodeShift)) | d.step)

	if rid < baseRID.Int64() || rid > currentRID.Int64() {
		return false
	}
	return true
}

func (d *dice) GenRandomString(length uint) (resStr string) {
	return d.stringByCharSet(int(length), encodeBaseChars)
}

func (d *dice) stringByCharSet(n int, charSet string) string {
	// Ref: https://stackoverflow.com/questions/22892120/how-to-generate-a-random-string-of-a-fixed-length-in-go
	b := make([]byte, n)
	for i := range b {
		r := <-chInt64
		b[i] = charSet[r%int64(len(charSet))]
	}
	return string(b)
}

// --- Below are RID advence application

// Int64 to get RID int64 digital number
func (t RID) Int64() int64 {
	return int64(t)
}
