// Code generated by mockery v2.20.0. DO NOT EDIT.

package mocks

import (
	big "math/big"

	ctx "github.com/hsuanshao/go-tools/ctx"

	mock "github.com/stretchr/testify/mock"
)

// Math is an autogenerated mock type for the Math type
type Math struct {
	mock.Mock
}

// ConvertBigIntToHexadecimal provides a mock function with given fields: _a0, bigNum
func (_m *Math) ConvertBigIntToHexadecimal(_a0 ctx.CTX, bigNum *big.Int) string {
	ret := _m.Called(_a0, bigNum)

	var r0 string
	if rf, ok := ret.Get(0).(func(ctx.CTX, *big.Int) string); ok {
		r0 = rf(_a0, bigNum)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ConvertDecimalStrToHexadecimalStr provides a mock function with given fields: _a0, decimalNum
func (_m *Math) ConvertDecimalStrToHexadecimalStr(_a0 ctx.CTX, decimalNum string) (string, error) {
	ret := _m.Called(_a0, decimalNum)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(ctx.CTX, string) (string, error)); ok {
		return rf(_a0, decimalNum)
	}
	if rf, ok := ret.Get(0).(func(ctx.CTX, string) string); ok {
		r0 = rf(_a0, decimalNum)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(ctx.CTX, string) error); ok {
		r1 = rf(_a0, decimalNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConvertHexadecimalStrToDecimalStr provides a mock function with given fields: _a0, hexadecimalNum
func (_m *Math) ConvertHexadecimalStrToDecimalStr(_a0 ctx.CTX, hexadecimalNum string) (string, error) {
	ret := _m.Called(_a0, hexadecimalNum)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(ctx.CTX, string) (string, error)); ok {
		return rf(_a0, hexadecimalNum)
	}
	if rf, ok := ret.Get(0).(func(ctx.CTX, string) string); ok {
		r0 = rf(_a0, hexadecimalNum)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(ctx.CTX, string) error); ok {
		r1 = rf(_a0, hexadecimalNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConvertHexadecimalToBigNum provides a mock function with given fields: _a0, hexadecimalNum
func (_m *Math) ConvertHexadecimalToBigNum(_a0 ctx.CTX, hexadecimalNum string) (*big.Int, error) {
	ret := _m.Called(_a0, hexadecimalNum)

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(ctx.CTX, string) (*big.Int, error)); ok {
		return rf(_a0, hexadecimalNum)
	}
	if rf, ok := ret.Get(0).(func(ctx.CTX, string) *big.Int); ok {
		r0 = rf(_a0, hexadecimalNum)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(ctx.CTX, string) error); ok {
		r1 = rf(_a0, hexadecimalNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConvertHexadecimalToInt64 provides a mock function with given fields: _a0, hexadecimalNum
func (_m *Math) ConvertHexadecimalToInt64(_a0 ctx.CTX, hexadecimalNum string) (*int64, error) {
	ret := _m.Called(_a0, hexadecimalNum)

	var r0 *int64
	var r1 error
	if rf, ok := ret.Get(0).(func(ctx.CTX, string) (*int64, error)); ok {
		return rf(_a0, hexadecimalNum)
	}
	if rf, ok := ret.Get(0).(func(ctx.CTX, string) *int64); ok {
		r0 = rf(_a0, hexadecimalNum)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*int64)
		}
	}

	if rf, ok := ret.Get(1).(func(ctx.CTX, string) error); ok {
		r1 = rf(_a0, hexadecimalNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConvertInt64ToHexadecimal provides a mock function with given fields: _a0, num
func (_m *Math) ConvertInt64ToHexadecimal(_a0 ctx.CTX, num int64) string {
	ret := _m.Called(_a0, num)

	var r0 string
	if rf, ok := ret.Get(0).(func(ctx.CTX, int64) string); ok {
		r0 = rf(_a0, num)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MaxFloat64 provides a mock function with given fields: x, y
func (_m *Math) MaxFloat64(x float64, y float64) float64 {
	ret := _m.Called(x, y)

	var r0 float64
	if rf, ok := ret.Get(0).(func(float64, float64) float64); ok {
		r0 = rf(x, y)
	} else {
		r0 = ret.Get(0).(float64)
	}

	return r0
}

// MaxInt provides a mock function with given fields: x, y
func (_m *Math) MaxInt(x int, y int) int {
	ret := _m.Called(x, y)

	var r0 int
	if rf, ok := ret.Get(0).(func(int, int) int); ok {
		r0 = rf(x, y)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MaxInt64 provides a mock function with given fields: x, y
func (_m *Math) MaxInt64(x int64, y int64) int64 {
	ret := _m.Called(x, y)

	var r0 int64
	if rf, ok := ret.Get(0).(func(int64, int64) int64); ok {
		r0 = rf(x, y)
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// MinFloat64 provides a mock function with given fields: x, y
func (_m *Math) MinFloat64(x float64, y float64) float64 {
	ret := _m.Called(x, y)

	var r0 float64
	if rf, ok := ret.Get(0).(func(float64, float64) float64); ok {
		r0 = rf(x, y)
	} else {
		r0 = ret.Get(0).(float64)
	}

	return r0
}

// MinInt provides a mock function with given fields: x, y
func (_m *Math) MinInt(x int, y int) int {
	ret := _m.Called(x, y)

	var r0 int
	if rf, ok := ret.Get(0).(func(int, int) int); ok {
		r0 = rf(x, y)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MinInt64 provides a mock function with given fields: x, y
func (_m *Math) MinInt64(x int64, y int64) int64 {
	ret := _m.Called(x, y)

	var r0 int64
	if rf, ok := ret.Get(0).(func(int64, int64) int64); ok {
		r0 = rf(x, y)
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

type mockConstructorTestingTNewMath interface {
	mock.TestingT
	Cleanup(func())
}

// NewMath creates a new instance of Math. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMath(t mockConstructorTestingTNewMath) *Math {
	mock := &Math{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
